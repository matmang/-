일단 먼저 매우 큰 정수형으로 만들기...
계산 방법은 필산과 똑같은 알고리즘 설계.

예외처리는 어느정도 함.
23-(-34)+40+25
23-((-34)-40)+25
1 + 3 -     0
위 3가지 경우 전부 정상적으로 작동.
단, 3(3+5)와 같은 경우는 못함. 다른거 신경쓰기도 너무 힘들어

1. 덧셈
정수형은 굉장히 쉬움
자릿수 별로 더하고 받아올림하면 끝.
-> 그러나 실수형은?
기본 골자는 똑같음. 자릿수 별로 더하고 받아올림하면 끝.
단, 소수점 위치 맞춰주기, 소수점 뒤에 있는 맨 끝 숫자가 0이라면 쓰지 않기
이를 어떻게 만들것인지..

2. 뺄셈
정수형은 굉장히 쉬움
자릿수 별로 빼고 받아내림하면 끝.
-> 그러나 실수형은?
기본 골자는 똑같음. 자릿수 별로 빼고 받아내림하면 끝.
단, 소수점 위치 맞춰주기, 소수점 뒤에 있는 맨 끝 숫자가 0이라면 쓰지 않기
이를 어떻게 만들것인지..

3. 곱셈
오히려 이게 쉬울수도.
정수형 알고리즘
필산하는 알고리즘을 그대로 사용할 것. (카라츠바, 고속 푸리에 변환 전부 생각해봤는데 못하겠음...)
실수형 알고리즘
1. 소수점 밑 자리수 각각 카운트 하기. ex) 123.123 -> 3, 12345.12 -> 2
2. 카운트 한 자리수 합 구하기. ex) 3 + 2
3. 정수형 알고리즘 소수점 떼고 사용하기. ex) 123123 * 1234512 = 151996820976
4. 카운트 한 자리수 합 만큼 소수점 왼쪽으로 이동. ex) 1519968.20976

4. 나눗셈(이건 도저히 실수로 못해먹겠음)
생략
